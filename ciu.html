<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> CIU </title>
  <link href="CIU.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="footer">
  <h2>Aleksander Borysov - CIU 2021/2022</h2>
  <h3>aleksander.borysov101@alu.ulpgc.es</h3>
</div>

<div class="header">
  <h2>Memoria de prácticas de CIU</h2>
</div>

<div class="row">
    <div class="card">
      <h2>Práctica 1: Kong</h2>
      <h5>Kong es un clon de Pong ambientado en la jungla, específicamente con tema simiesco., Feb 14, 2022</h5>
      <div class="fakeimg" style="height: 640px;">
        <img src="kong.gif" alt="Kong gameplay"  width="800px" />
      </div>
      <h4>Fase de diseño:</h4>
      <p>
        Aposté por un diseño 8-bit. Simplificado, asimilando una mayoría de la estructura inicial de pong. La idea era aportar al usuario una buena experiencia
        con lo mínimo necesario. En todo momento tenemos un fondo negro. Sobre eso, empezamos a construir. Primero, el menú principal, que consiste en dos imágenes
        y dos textos. Las imagenes y el primer texto explican qué botones emplear para controlar el jugador de cada lado (bananas). El texto parpadeando incita al
        usuario a participar, indicando que se debe pulsar una tecla para comenzar. Las teclas elegidas son estándar en la industria de los videojuegos, por lo que
        usuarios experimentados se adaptarán enseguida. Los usuarios con poca experiencia tendrán que adaptarse, pero las flechas son bastante intuitivas. Quizá WASD
        de algún dolor de cabeza a alguno, pero no debería llevar más de un minuto en entenderse.
        
        Una vez ha comenzado la partida, la pelota saldrá en una dirección aleatoria tras un momento de espera. La puntuación está en el lado superior de la pantalla,
        que suele ser el primer sitio donde el usuario mira. Los plátanos tienen un control responsive, sin retardo y sin salirse del marco del juego.
        Los colores son claros y contrastados con el fondo, para diferenciar los elementos dinámicos de los estáticos de la partida. La pelota va acelerándose conforme
        va rebotando contra los jugadores, para darle una emoción incremental a la partida y evitar aburrir con la monotonía de su velocidad. Esto combina bien con
        el inicio aleatorio del balón. 

        Con los sonidos y animaciones se priorizó ofrecer feedback al jugador. Intentar ofrecerle una explicación implícita de lo que está ocurriendo. También hay
        variación en los sonidos, porque la monotonía de un solo efecto puede llegar a cansar los oídos bastante.
        
        La pantalla de juego tiene unas dimensiones estandar (800x600). Sería posible encajarla en cualquier pantalla y/o formato. También, al estar en ventana, titulamos
        la ventana y aportamos un icono identificativo del juego.
        <ul>
          <li>Consistencia: una misma temática para el juego basada en color e ideas concretas.</li>
          <li>Usabilidad universal: pantalla versátil y processing está basado en la JVM (Java Virtual Machine).</li>
          <li>Feedback informativo: sonidos, animaciones y reacciones/movimientos inmediatos.</li>
          <li>Diálogo: pantalla de inicio informativa.</li>
          <li>Prevención de errores: antes de finiquitar el proyecto hubo una sesión de pulido, que revisó la satisfacción en la interacción y redujo bugs.</li>
          <li>Reversibilidad: para reiniciar la partida, basta con reiniciar la aplicación.</li>
          <li>Usuario en control: los usuarios están en control en todo momento de lo que ocurre en el juego</li>
          <li>Reducir la carga de la memoria a corto plazo: no hará falta recordar nada más que los controles, todo es intuitivo o está escrito. </li>
        </ul>
        
      </p>
      <h4>Etapas del desarrollo:</h4>
      <p>
        <ul>
          <li>Creamos una animación a partir de un gif de un gorila brillando. Nos apoyamos en la clase Animation</li>
          <li>Renderizamos una pelota, y con la inclusión de movimiento su clase Ball.</li>
          <li>Como la bola y los cuerpos de los jugadores son similares, creamos una interfaz Figure para que compartan comportamiento.</li>
          <li>Queremos que la bola comience con un retardo para que de tiempo a los jugadores a situarse, también le aleatorizamos el lanzamiento.</li>
          <li>Lo siguiente es hacer que los jugadores se muevan, conseguimos esto mediante patrón Command.</li>
          <li>Nos topamos con el problema de que los jugadores no pueden accionar teclas simultáneamente. 
            Lo resolvemos con keyPressed() y keyReleased(). Estos metodos activan y desactivan el movimiento hacia arriba/abajo de los jugadores.</li>
          <li>El juego aún necesita colisiones. Construimos colisiones para los jugadores con la pelota y la pelota con el entorno</li>
          <li>Segun las colisiones se lanzan eventos: Pelota - pared del fondo puntúa. Pelota - pared inferior/superior rebota. Pelota - jugador rebota</li>
          <li>Implementamos un menú principal, que explique los controles y lance la partida cuando los jugadores estén listos.</li>
          <li>Implementamos UI para el juego (linea divisoria de los campos de juego, puntaje)</li>
          <li>Por último incluimos sonidos</li>
        </ul>
      </p>
      <h4>Herramientas y referencias:</h4>
      <p>
        <ul>
          <li>ezgif, herramienta de manipulación de GIFS. <a href="https://ezgif.com/">https://ezgif.com/</a></li>
          <li>processing reference. <a href="https://processing.org/reference">https://processing.org/reference</a></li>
          <li>w3shcools, para el desarrollo de la web. <a href="https://www.w3schools.com/">https://www.w3schools.com/</a></li>
          <li>8 reglas de schneiderman, para un diseño adecuado de la aplicación <a href="https://www.cs.umd.edu/users/ben/goldenrules.html">https://www.cs.umd.edu/users/ben/goldenrules.html</a></li>
          <li>Algunos efectos de sonido <a href="https://opengameart.org/content/512-sound-effects-8-bit-style">https://opengameart.org/content/512-sound-effects-8-bit-style</a></li>
          <li>otsedom.github.io/README.md, idea general para realizar el proyecto <a href="https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P1/README.md">https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P1/README.md</a></li>
          <li>Gyazo para grabar el gif de esta página <a href="https://gyazo.com/">https://gyazo.com/</a></li>
          <li>Google imágenes para encontrar iconos e imagenes adecuadas</li>
          <li>StackOverflow para resolución de errores <a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li>
        </ul>
      </p>
    </div>
</div>

<div class="row">
  <div class="card">
    <h2>Práctica 2: Solid of revolution viewer</h2>
    <h5>Realizamos un visor de sólidos de revolución, generados dibujando el perfil de una figura. Feb 18, 2022</h5>
    <div class="fakeimg" style="height: 760px;">
      <img src="revolution.gif" alt="Solid of revolution"  width="1280px" />
    </div>
    <h4>Fase de diseño:</h4>
    <p>
      Quería una aplicación simple, que no fuese engorrosa o difícil de entender. Entonces, lo más importante es reducir el tiempo que el usuario pasa adecuándose a
      la aplicación y hacer que quiera y pueda pasar más tiempo haciendo uso de ella. Para esto he intentado limitar el texto a mínimos y comunicar a la aplicación
      con la persona mediante el canal visual.
      
      La pantalla de juego tiene unas dimensiones estándar (1280x720). Sería posible encajarla en cualquier pantalla y/o formato. También, al estar en ventana, titulamos
      la ventana y aportamos un icono identificativo del juego.

      Construimos el lienzo con un fondo en negro. Lo primero que se encuentra el usuario es una linea divisoria verde. Tiene una UI que le indica dos cosas, la más
      importante es el texto que indica el botón de ayuda (H). En cuanto el usuario haya leído la ayuda, entenderá de que se trata el otro elemento de la UI. En caso 
      contrario, tampoco es un elemento muy importante. Ese elemento indica la precisión con la que se dibuja la figura, es decir, cuánto se abre el ángulo cada paso.

      La persona usando la aplicación, tiene que dibujar el perfil de una figura a la derecha del eje verde. Una vez esté dibujada pulsará ENTER para generar el
      sólido de revolución. Se podrá girar y hacer zoom sobre ella. Subir y bajar el nivel de detalle en directo y pulsar ENTER para volver a dibujar otra.
      <ul>
        <li>Consistencia: una misma temática para la aplicación basada en color uniforme (negro, verde y blanco).</li>
        <li>Usabilidad universal: pantalla versátil y processing está basado en la JVM (Java Virtual Machine). El inglés es el idioma más popular en la informática.</li>
        <li>Feedback informativo: animaciones y reacciones/movimientos inmediatos. UI informativa.</li>
        <li>Diálogo: el usuario tiene a mano en todo momento y de forma clara la información necesaria.</li>
        <li>Prevención de errores: se diseña una aplicación modular que permita el testeo de los módulos individuales para que luego en su totalidad funcionen bien.</li>
        <li>Reversibilidad: pulsar ENTER siempre te devuelve a la fase de dibujado.</li>
        <li>Usuario en control: los usuarios están en control en todo momento de lo que ocurre en la aplicación.</li>
        <li>Reducir la carga de la memoria a corto plazo: no hará falta recordar nada más que los controles, todo es intuitivo o está escrito.</li>
      </ul>
    </p>
    <h4>Etapas del desarrollo:</h4>
    <p>
      <ul>
        <li>Creamos la pantalla de vista de dibujo. Aquí introducimos el dibujado del eje vertical, de los puntos que marquemos con el ratón, y una línea
            guía que los une.</li>
        <li>Ahora queremos una serie de controles que nos permita transicionar entre modos de dibujo y vista de la figura, y más en el futuro, al modo de ayuda.</li>
        <li>ShapeBuilder: Después, necesitamos que se dibuje algo en el modo de dibujo. Creamos la PShape y una rutina que la construya.
          Esto es más fácil decirlo que hacerlo, necesitamos tejer una malla de triángulos. Para conseguirlo basta simplemente con unir el vértice 0 de la lista
        con su rotación siguiente y esta con el vértice 1 de la lista, repitiéndose el proceso anterior.</li>
        <li>Camera: Usando peasycam, podemos hacer una cámara interactiva. Esto ayudaría al usuario navegar alrededor de la figura. Lo bueno de esta herramienta
          es que el código se reduce mucho, y en caso de necesitarlo, puedes tomar las riendas del control de la librería.</li>
        <li>Queda resolver el problema de usabilidad n1. Que el usuario pueda usar la aplicación. Si ponemos una UI, es posible que el usuario se sienta mucho
          más cómodo con ella. Dibujamos un indicador de la precisión de dibujado, un recordatorio permanente de cómo acceder a la ayuda y la ayuda en sí.</li>
        <li>En este punto el código estaba un poco desordenado, la cámara se confundía con las transformaciones y el objeto 3D tenía un problema de dibujado.
          Decidí reescribir el código y separar las responsabilidades en ficheros distintos. También recorte una feature que tenía el código que se volvía un poco
          inútil y hacía que algunas cosas funcionasen mal. Esta calculaba el alcance que debía tener la cámara dependiendo del tamaño de la pantalla. Pero como
          esta sería fija, también fijé el alcance de la cámara. 
        </li>
      </ul>
    </p>
    <h4>Herramientas y referencias:</h4>
    <p>
      <ul>
        <li>ezgif, herramienta de manipulación de GIFS. <a href="https://ezgif.com/">https://ezgif.com/</a></li>
        <li>processing reference. <a href="https://processing.org/reference">https://processing.org/reference</a></li>
        <li>w3shcools, para el desarrollo de la web. <a href="https://www.w3schools.com/">https://www.w3schools.com/</a></li>
        <li>8 reglas de schneiderman, para un diseño adecuado de la aplicación <a href="https://www.cs.umd.edu/users/ben/goldenrules.html">https://www.cs.umd.edu/users/ben/goldenrules.html</a></li>
        <li>otsedom.github.io/README.md, idea general para realizar el proyecto <a href="https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P2/README.md">https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P2/README.md</a></li>
        <li>Gyazo para grabar el gif de esta página <a href="https://gyazo.com/">https://gyazo.com/</a></li>
        <li>StackOverflow para resolución de errores <a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li>
      </ul>
    </p>
  </div>
</div>

<div class="row">
  <div class="card">
    <h2>Práctica 3: Space</h2>
    <h5>Realizamos un simulador de un mini-sistema solar. Feb 28, 2022</h5>
    <div class="fakeimg" style="height: 460px;">
      <img src="space.gif" alt="Space" width="800px" />
    </div>
    <h4>Fase de diseño:</h4>
    <p>
      La aplicación es sencilla. Necesitaba un fondo, que es una esfera gigante con una textura espacial. Luego, varias esferas mucho más pequeñas que estuviesen
      texturizadas e interactuasen entre sí. Habrá musica, luces y movimiento.
      
      La pantalla de juego tiene unas dimensiones estándar (800x600). Sería posible encajarla en cualquier pantalla y/o formato. También, al estar en ventana, titulamos
      la ventana y aportamos un icono identificativo del juego. Pero lo colocamos a pantalla completa.

      El usuario puede mover la camara y salir de la aplicación.
      <ul>
        <li>Consistencia: Tema espacial, todos los elementos tratan de respetarlo.</li>
        <li>Usabilidad universal: Pantalla versátil y processing está basado en la JVM (Java Virtual Machine). El inglés es el idioma más popular en la informática.</li>
        <li>Feedback informativo: Animaciones y reacciones/movimientos inmediatos. UI informativa.</li>
        <li>Diálogo: El usuario tiene a mano en todo momento y de forma clara la información necesaria.</li>
        <li>Prevención de errores: Se diseña una aplicación modular que permita el testeo de los módulos individuales para que luego en su totalidad funcionen bien.</li>
        <li>Reversibilidad: Faltaría un botón que resetease la cámara, pero como está sobre un eje central (Sol) no es tan grave.</li>
        <li>Usuario en control: Los usuarios están en control en todo momento de lo que ocurre en la aplicación.</li>
        <li>Reducir la carga de la memoria a corto plazo: No hará falta recordar nada.</li>
      </ul>
    </p>
    <h4>Etapas del desarrollo:</h4>
    <p>
      <ul>
        <li>Creamos una esfera gigante y le ponemos una textura espacial con polar mapping (adaptada a esferas).</li>
        <li>Como todo ocurrirá dentro de esa esfera, pondremos la camara en el centro.</li>
        <li>Dibujamos la UI y proporcionamos las acciones que presta. Simplemente texto.</li>
        <li>Colocamos los planetas y la Luna.</li>
        <li>Ponemos música.</li>
        <li>Ponemos luz, prendemos el Sol.</li>
      </ul>
    </p>
    <h4>Herramientas y referencias:</h4>
    <p>
      <ul>
        <li>ezgif, herramienta de manipulación de GIFS. <a href="https://ezgif.com/">https://ezgif.com/</a></li>
        <li>processing reference. <a href="https://processing.org/reference">https://processing.org/reference</a></li>
        <li>w3shcools, para el desarrollo de la web. <a href="https://www.w3schools.com/">https://www.w3schools.com/</a></li>
        <li>8 reglas de schneiderman, para un diseño adecuado de la aplicación <a href="https://www.cs.umd.edu/users/ben/goldenrules.html">https://www.cs.umd.edu/users/ben/goldenrules.html</a></li>
        <li>otsedom.github.io/README.md, idea general para realizar el proyecto <a href="https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P3/README.md">https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P3/README.md</a></li>
        <li>Gyazo para grabar el gif de esta página <a href="https://gyazo.com/">https://gyazo.com/</a></li>
        <li>StackOverflow para resolución de errores <a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li>
      </ul>
    </p>
  </div>
</div>

<div class="row">
  <div class="card">
    <h2>Práctica 4: Space pero con una cámara hecha por mi</h2>
    <h5>Realizamos un simulador de un mini-sistema solar. Pero esta vez con una cámara propia. Mar 6, 2022</h5>
    <div class="fakeimg" style="height: 460px;">
      <img src="space.gif" alt="Space" width="800px" />
    </div>
    <h4>Fase de diseño:</h4>
    <p>
      Partimos del diseño anterior.

      Caben destacar unas limitaciones de la cámara, que se hacen obvias tras usar la librería Peasy. La primera es el uso del ratón, que es seguramente más
      cómodo para la mayoría. Y la segunda, es que no hay realineación del eje sobre el que se desplaza la cámara cuando hay un cambio de orientación.
      <ul>
        <li>Consistencia: Tema espacial, todos los elementos tratan de respetarlo.</li>
        <li>Usabilidad universal: Pantalla versátil y processing está basado en la JVM (Java Virtual Machine). El inglés es el idioma más popular en la informática.</li>
        <li>Feedback informativo: Animaciones y reacciones/movimientos inmediatos. UI informativa.</li>
        <li>Diálogo: El usuario tiene a mano en todo momento y de forma clara la información necesaria.</li>
        <li>Prevención de errores: Se diseña una aplicación modular que permita el testeo de los módulos individuales para que luego en su totalidad funcionen bien.</li>
        <li>Reversibilidad: Con la R el usuario vuelve a la posición inicial.</li>
        <li>Usuario en control: Los usuarios están en control en todo momento de lo que ocurre en la aplicación.</li>
        <li>Reducir la carga de la memoria a corto plazo: No hará falta recordar nada.</li>
      </ul>
    </p>
    <h4>Etapas del desarrollo:</h4>
    <p>
      <ul>
        <li>Proponemos un diseño que modifique unas variables que modularan los parámetros por defecto de la cámara. Pulsar W aumenta cameraPositionZ, que se le
          resta al valor por defecto de la posición de la cámara en Z. Todo lo apoyamos en el método camera.
        </li>
      </ul>
    </p>
    <h4>Herramientas y referencias:</h4>
    <p>
      <ul>
        <li>ezgif, herramienta de manipulación de GIFS. <a href="https://ezgif.com/">https://ezgif.com/</a></li>
        <li>processing reference. <a href="https://processing.org/reference">https://processing.org/reference</a></li>
        <li>w3shcools, para el desarrollo de la web. <a href="https://www.w3schools.com/">https://www.w3schools.com/</a></li>
        <li>8 reglas de schneiderman, para un diseño adecuado de la aplicación <a href="https://www.cs.umd.edu/users/ben/goldenrules.html">https://www.cs.umd.edu/users/ben/goldenrules.html</a></li>
        <li>otsedom.github.io/README.md, idea general para realizar el proyecto <a href="https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P4/README.md">https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P4/README.md</a></li>
        <li>Gyazo para grabar el gif de esta página <a href="https://gyazo.com/">https://gyazo.com/</a></li>
        <li>StackOverflow para resolución de errores <a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li>
      </ul>
    </p>
  </div>
</div>

<div class="row">
  <div class="card">
    <h2>Práctica 5: Visualización de datos syticleta</h2>
    <h5>Realizamos una presentación de los datos del servicio de transporte público de Las Palmas de Gran Canaria, Syticleta. Mar 16, 2022</h5>
    <div class="fakeimg" style="height: 1650px;">
      <img src="syticleta.gif" alt="Sitycleta" width="1164px" />
    </div>
    <h4>Fase de diseño:</h4>
    <p>
      La idea inicial era colocar puntos con interactividad sobre un mapa de Las Palmas, cada uno correspondiente a estaciones de la Syticleta. A eso se le añadió
      el trazado de rutas y tamaño dinámico.

      NOTA: Hay algunos nodos que no presentan datos. Principalmente es porque los datos que presenta sagulpa no son consistentes, les falta realineación con el nombre real
      de algunas estaciones.
      <ul>
        <li>Consistencia: Selección de colores que no se confundan entre ellos. Es una temática de mapa y se puede discernir cada elemento de la pantalla.</li>
        <li>Usabilidad universal: Pantalla versátil y processing está basado en la JVM (Java Virtual Machine). El inglés es el idioma más popular en la informática.</li>
        <li>Feedback informativo: Animaciones y reacciones/movimientos inmediatos. UI informativa.</li>
        <li>Diálogo: El usuario tiene a mano en todo momento y de forma clara la información necesaria.</li>
        <li>Prevención de errores: Se diseña una aplicación modular que permita el testeo de los módulos individuales para que luego en su totalidad funcionen bien.</li>
        <li>Reversibilidad: Con la R el usuario vuelve a la posición inicial.</li>
        <li>Usuario en control: Los usuarios están en control en todo momento de lo que ocurre en la aplicación.</li>
        <li>Reducir la carga de la memoria a corto plazo: No hará falta recordar nada.</li>
      </ul>
    </p>
    <h4>Etapas del desarrollo:</h4>
    <p>
      <ul>
        <li>Primero creé la clase que haría objetos de círculos que crecen cuando pasas el ratón por encima. Son customizables en color, tamaño, de cuánto a cuánto crecen...</li>
        <li>Después, la clase mapa. Alberga una imagen y un cerco de coordenadas cartográficas. Además, se le proporciona la capacidad de hacer zoom y moverse.</li>
        <li>Ahora es momento de renderizar el mapa y colocar los puntos sobre él. Tenemos que leer los datos de geolocalización que están en el fichero pertinente.</li>
        <li>Cada línea es una estación, y cada estación es un punto. Extraeremos el nombre y localización. Más adelante, también averiguaremos cuántas rutas salen de esa estación,
          eso determinará el tamaño inicial de cada círculo. Mientras, también almacenamos en cada círculo ocurrencias de otros círculos, para contar cuántos viajes salen hacia
          allí.</li>
        <li>Pintamos los círculos con los parámetros obtenidos y un color aleatorio de una gama establecida de colores fríos. Tenemos otra gama de colores calientes para las
          líneas que representarán las rutas.</li>
        <li>Ahora, cuando una persona pase el ratón sobre un círculo crecerá y mostrará su nombre, acompañado de lineas que lo unen con los destinos desde esa estación. Cuanto
          más oscuro sea el color de la línea, más asiduamente se toma esa ruta.</li>
        <li>Queda pintar un HUD que informe al usuario de lo que tiene que hacer, porque sin el HUD podría perderse. Por último y como detalle, añadimos un ciclo de día y
          noche para experimentar con la iluminación.</li>
      </ul>
    </p>
    <h4>Herramientas y referencias:</h4>
    <p>
      <ul>
        <li>Peek para grabar el GIF. <a href="https://github.com/phw/peek">https://github.com/phw/peek</a></li>
        <li>processing reference. <a href="https://processing.org/reference">https://processing.org/reference</a></li>
        <li>w3shcools, para el desarrollo de la web. <a href="https://www.w3schools.com/">https://www.w3schools.com/</a></li>
        <li>8 reglas de schneiderman, para un diseño adecuado de la aplicación <a href="https://www.cs.umd.edu/users/ben/goldenrules.html">https://www.cs.umd.edu/users/ben/goldenrules.html</a></li>
        <li>otsedom.github.io/README.md, idea general para realizar el proyecto <a href="https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P5/README.md">https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P5/README.md</a></li>
        <li>StackOverflow para resolución de errores <a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li>
      </ul>
    </p>
  </div>
</div>

<div class="row">
  <div class="card">
    <h2>Práctica 6: Cámara y OpenCV</h2>
    <h5>Jugamos con la librería de vídeo y OpenCV de Processing. Mar 16, 2022</h5>
    <div class="fakeimg" style="height: 640px;">
      <img src="camera.gif" alt="Camera" width="800px" />
    </div>
    <h4>Fase de diseño:</h4>
    <p>
      Construiremos una aplicación que utilice la webcam del usuario. Se podrán usar varios modos, entre ellos: Brillo, umbralizado, filtro de cara feliz, negativo...
      El modo cambia cuando damos click y algunos presentan interactividad, en tanto que mover el ratón de lado a lado cambiará el aspecto de la cámara.
      <ul>
        <li>Consistencia: Selección de colores que no se confundan entre ellos. Es una temática de mapa y se puede discernir cada elemento de la pantalla.</li>
        <li>Usabilidad universal: Pantalla versátil y processing está basado en la JVM (Java Virtual Machine). El inglés es el idioma más popular en la informática.</li>
        <li>Feedback informativo: Animaciones y reacciones/movimientos inmediatos. UI informativa.</li>
        <li>Diálogo: El usuario tiene a mano en todo momento y de forma clara la información necesaria.</li>
        <li>Prevención de errores: Se diseña una aplicación modular que permita el testeo de los módulos individuales para que luego en su totalidad funcionen bien.</li>
        <li>Reversibilidad: Todos los modos, en todo momento son alcanzables haciendo clic.</li>
        <li>Usuario en control: Los usuarios están en control en todo momento de lo que ocurre en la aplicación.</li>
        <li>Reducir la carga de la memoria a corto plazo: No hará falta recordar nada.</li>
      </ul>
    </p>
    <h4>Etapas del desarrollo:</h4>
    <p>
      <ul>
          <li>Primero hay que asegurarse de que la cámara funciona bien sin modificaciones. Creamos un esqueleto de aplicación que configura la cámara y cada iteración del bucle
          draw() extraiga un fotograma de la cámara y lo muestre.</li>
          <li>Después, en lugar de mostrar el fotograma de la cámara, mostraremos el fotograma que tiene cargado OpenCV. Previemente, habremos de haberselo proporcionado.</li>
          <li>Cuando OpenCV tiene cargada una imagen, podemos hacer modificaciones directamente sobre ella. Así construimos muchos de los filros.</li>
          <li>Creamos varios modos con los elementos que nos ofrece OpenCV y los hacemos rotar con el clic del ratón.</li>
      </ul>
    </p>
    <h4>Herramientas y referencias:</h4>
    <p>
      <ul>
        <li>Peek para grabar el GIF. <a href="https://github.com/phw/peek">https://github.com/phw/peek</a></li>
        <li>processing reference. <a href="https://processing.org/reference">https://processing.org/reference</a></li>
        <li>w3shcools, para el desarrollo de la web. <a href="https://www.w3schools.com/">https://www.w3schools.com/</a></li>
        <li>8 reglas de schneiderman, para un diseño adecuado de la aplicación <a href="https://www.cs.umd.edu/users/ben/goldenrules.html">https://www.cs.umd.edu/users/ben/goldenrules.html</a></li>
        <li>otsedom.github.io/README.md, idea general para realizar el proyecto <a href="https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P6/README.md">https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P6/README.md</a></li>
        <li>StackOverflow para resolución de errores <a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li>
      </ul>
    </p>
  </div>
</div>

<div class="row">
  <div class="card">
    <h2>Práctica 7: Piano loco</h2>
    <h5>Jugamos con la librería Minim aplicándola a un piano. Mar 28, 2022</h5>
    <div class="fakeimg" style="height: 760px;">
      <img src="piano.gif" alt="Piano" width="1280px" />
    </div>
    <h4>Fase de diseño:</h4>
    <p>
      El objetivo es construir un piano que se toque con las teclas del teclado. Que además, se muestre la salida de audio en forma de onda en la pantalla inferior
      del piano y, cuando el usuario quiera, se pueda cambiar de modo (el tipo de onda). Como curiosidad añadida, he preferido que no hayan límites a la capacidad
      de experimentación del usuario. Que se vea reflejado en todo momento el efecto que tiene el sonido sobre la onda, con pulsaciones repetidas, mantenidas y desordenadas.
      De ahí viene la idea de un piano loco. Como pega, hay que decir que usa una disposición de teclado ANSI, por lo que los teclados ISO pueden llegar a tener dificultades
      con las dos últimas teclas "[", "]". Dado el número de teclas del piano, la alternativa en un teclado español sería imposible, puesto que habría que usar '`' y '+'.
      <ul>
        <li>Consistencia: Selección de colores que no se confundan entre ellos. Es una temática de piano de madera y se puede discernir cada elemento de la pantalla.</li>
        <li>Usabilidad universal: Pantalla versátil y processing está basado en la JVM (Java Virtual Machine). El inglés es el idioma más popular en la informática.</li>
        <li>Feedback informativo: Animaciones y reacciones/movimientos inmediatos. UI informativa.</li>
        <li>Diálogo: El usuario tiene a mano en todo momento y de forma clara la información necesaria.</li>
        <li>Prevención de errores: Se diseña una aplicación modular que permita el testeo de los módulos individuales para que luego en su totalidad funcionen bien.</li>
        <li>Reversibilidad: Todos los modos, en todo momento son alcanzables pulsando ESPACIO.</li>
        <li>Usuario en control: Los usuarios están en control en todo momento de lo que ocurre en la aplicación.</li>
        <li>Reducir la carga de la memoria a corto plazo: No hará falta recordar nada.</li>
      </ul>
    </p>
    <h4>Etapas del desarrollo:</h4>
    <p>
      <ul>
          <li>Creamos una clase Keyboard que maneje lo que hacer con el input, que construya las teclas, que las ordene y les asigne notas...</li>
          <li>Creamos una clase KeyboardSound que implementa la interfaz instrument de Minim, para poder hacer uso de las notas y jugar con los sonidos.</li>
          <li>Por último una clase Key, que se encargue de construirse y reaccionar a su pulsación, cambiando de color y sonando.</li>
          <li>Todo se entrelaza en el fichero principal, donde además introducimos la interfaz osciloscópica.</li>
      </ul>
    </p>
    <h4>Herramientas y referencias:</h4>
    <p>
      <ul>
        <li>ezgif, herramienta de manipulación de GIFS. <a href="https://ezgif.com/">https://ezgif.com/</a></li>
        <li>processing reference. <a href="https://processing.org/reference">https://processing.org/reference</a></li>
        <li>w3shcools, para el desarrollo de la web. <a href="https://www.w3schools.com/">https://www.w3schools.com/</a></li>
        <li>8 reglas de schneiderman, para un diseño adecuado de la aplicación <a href="https://www.cs.umd.edu/users/ben/goldenrules.html">https://www.cs.umd.edu/users/ben/goldenrules.html</a></li>
        <li>otsedom.github.io/README.md, idea general para realizar el proyecto <a href="https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P7/README.md">https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P7/README.md</a></li>
        <li>Gyazo para grabar el gif de esta página <a href="https://gyazo.com/">https://gyazo.com/</a></li>
        <li>StackOverflow para resolución de errores <a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li>
        <li>Documentación online de Minim <a href="https://code.compartmental.net/minim/">https://code.compartmental.net/minim/</a></li>
      </ul>
    </p>
  </div>
</div>

<div class="row">
  <div class="card">
    <h2>Práctica 10-11: Shaders</h2>
    <h5>Usamos glsl para crear una animación de ciclo día-noche sobre la hierba. May 3, 2022</h5>
    <div class="fakeimg" style="height: 640px;">
      <img src="sun&moon.gif" alt="Sun and moon" width="800px" />
    </div>
    <h4>Fase de diseño:</h4>
    <p>
      El shader mostrara una hierba con un cielo. En este cielo, se sucederá el día y la noche con su respecitvo sol y luna.
      <ul>
        <li>Es más un video que una aplicación, no aplicaría las reglas de schneiderman.</li>
      </ul>
    </p>
    <h4>Etapas del desarrollo:</h4>
    <p>
      <ul>
          <li>Creamos la hierba con una función de modulo.</li>
          <li>El cielo es una transición de azul a blanco o de azul a negro, respectivamente.</li>
          <li>El sol y la luna se crean de la misma manera (4 rectangulos).</li>
          <li>Se calcula la translación con el seno y coseno (giran en círculo)</li>
          <li>Hay un desfase de PI, entre el sol y la luna, por lo que en todo momento estarán en el lado contrario al otro.</li>
      </ul>
    </p>
    <h4>Herramientas y referencias:</h4>
    <p>
      <ul>
        <li>ezgif, herramienta de manipulación de GIFS. <a href="https://ezgif.com/">https://ezgif.com/</a></li>
        <li>processing reference. <a href="https://processing.org/reference">https://processing.org/reference</a></li>
        <li>w3shcools, para el desarrollo de la web. <a href="https://www.w3schools.com/">https://www.w3schools.com/</a></li>
        <li>otsedom.github.io/README.md, idea general para realizar el proyecto <a href="https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P7/README.md">https://github.com/otsedom/otsedom.github.io/blob/main/CIU/P7/README.md</a></li>
        <li>Gyazo para grabar el gif de esta página <a href="https://gyazo.com/">https://gyazo.com/</a></li>
        <li>StackOverflow para resolución de errores <a href="https://stackoverflow.com/">https://stackoverflow.com/</a></li>
        <li>The book of shaders <a href="https://thebookofshaders.com/">https://thebookofshaders.com/</a></li>
      </ul>
    </p>
  </div>
</div>

<div class="footer">
  <h2>Aleksander Borysov - CIU 2021/2022</h2>
  <h3>aleksander.borysov101@alu.ulpgc.es</h3>
</div>
  
</body>
</html>